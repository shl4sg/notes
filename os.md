#### 进程间通讯的7种方式

**管道**（pipe）：管道是一种半双工的通信方式，数据只能单向流动，管道只能用于父子进程或者兄弟进程间通信。

**命名管道**（FIFO）：有名管道也是半双工的通信方式，它允许无亲缘关系进程间的通信。

**信号** ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

**消息队列**（MessageQueue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

**共享存储**（SharedMemory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

**信号量**（Semaphore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

**套接字**（Socket）：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机的进程通信。

 

#### 线程与进程

##### 进程

进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。

##### 线程

线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。每个线程只拥有一些在运行中必不可少的私有属性，比如tcb、线程Id、栈、寄存器。

##### 联系

线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

##### 区别

进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和寄存器，线程之间切换的开销小。

所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分。

 

####  分页

#### 请你说一说操作系统中的程序的内存结构

一个程序本质上都是由BSS段、data段、text段三个组成的。

地址从低到高为：text，data，bss，heap，stack，env（命令行参数和环境变量）

![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153)

**bss段**：bss段（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量的一块内存区域。bss段属于静态内存分配。

**data段**：数据段通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。

**text段**：代码段通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

**堆**：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上；当利用free等函数释放内存时，被释放的内存从堆中被剔除。

**栈**：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

C++ 有只读数据段(rotate) :

存放字符串常亮,const变量,虚函数表.

堆中的对象实例包含虚函数表指针,栈中包含对象指针

 

#### 类的内存分布

##### 1、static修饰符

1）static修饰成员变量

为该类型的所有对象所共享(包括其派生类)。因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。

2）static修饰成员函数

与普通的成员函数相比，静态成员函数不与任何的对象相联系，因此它不具有this指针。它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。Static修饰的成员函数，在代码区分配内存。

##### 2、C++继承和虚函数

C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。

动态多态实现有几个条件：(1)虚函数；(2)一个基类的指针或引用指向派生类的对象；

基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。

每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。

虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。

##### 3、virtual修饰符

如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。

如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。

![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA)

#### Linux虚拟地址空间

为了更加高效、安全地管理内存，os提供了对物理内存的抽象，称为虚拟内存。

1. 它将主存看成是一个存储在磁盘空间上的地址空间的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。
2. 它为内阁进程提供了一致的地址空间,简化了内存管理。
3. 它保护了每个进程的地址空间不被其他进程破坏。

虚拟内存的作用：**缓存**，**内存管理**，**内存保护**

##### 1、缓存

虚拟内存被组织为一个存放在磁盘上的连续字节数组。每字节都有一个唯一的虚拟地址，作为数组的索引。磁盘上的内容被缓存在主存中。

VM系统将虚拟内存分割为大小固定的块，称为**虚拟页（VP）**，来作为磁盘和主存之间的传输单元。物理内存也被分割为**物理页（PP）**（也称为**页帧**），大小同虚拟页。页表是记录虚拟页和物理页映射关系的一种数据结构，页表由操作系统维护。页命中指cpu要访问的虚拟页是被缓存到物理内存中的。缺页是指要访问的页未缓存，会引发缺页异常，操作系统会将该页与物理内存中的一个页置换。

##### 2、内存管理

操作系统为每个进程提供一个独立的页表，因而也就是独立的虚拟地址空间。多个虚拟页面可以映射到同一个共享的物理页面上。VM简化了加载和链接、代码和数据的共享，以及应用程序的内存分配。

1、简化链接

独立地址空间允许每个进程的内存映像使用相同的基本格式。例如在64位x86-64平台上，代码段总是从虚拟地址0x400000开始。这样的一致性极大地简化了链接器的设计和实现。

2、简化加载

把目标文件加载到一个新创建的进程中，os为代码和数据段分配虚拟页，将页表条目指向目标文件中适当的位置。但是并不缓存任何数据到物理内存中，由虚拟内存系统按需自动调入数据页。

3、简化共享

在部分情况下，进程间还是需要共享代码和数据的，例如每个C程序都会调用C标准库中的程序（printf）、都需要调用相同的内核代码。操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而使多个进程共享这部分代码。

4、简化内存分配

由于页表的存在，操作系统在分配k个连续的虚拟页面时，可以将它们随机地分散映射在物理内存中。

##### 3.虚拟内存作为内存保护的工具

操作系统会控制进程对内存系统的访问，例如：

不允许一个用户进程修改它的只读代码段、内核代码和数据、其他进程私有内存等；

好处：

1.扩大地址空间。

2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。

3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。

4.当进程通信时，可采用虚存共享的方式实现。

5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存

6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高

7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片

#### 大小端

存储从低地址开始，先存储高位为大端，存储低位为小端。

小端：便于数据类型转换，高位直接截掉

大端：便于符号判断，符号位在低地址，直接判断

用途：小端常见于本地主机，大端常见于网络通信。

#### 内存对齐原因：

1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。